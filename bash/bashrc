#!/usr/bin/env bash

set -o vi

# private aliases and variables
source ~/Documents/private/configs/bashrc

# make sure executables can be run from $HOME/.local/bin
PATH=${PATH}:${HOME}/.local/bin

if [ "$TERM" == "xterm" ]; then
    export TERM=xterm-256color
fi

# input and default editor
EDITOR=vim

source $dotfiles_dir/bash/grc.bashrc    # colorize some common commands
# colorize git command line
source $dotfiles_dir/bash/git-prompt.sh
Red="\[\033[1;31m\]"
Green="\[\033[1;32m\]"
Reset="\[$(tput sgr0)\]"
export PS1=$Green'\w'$Reset'\n '
export PS1='$(git branch &>/dev/null;\
if [ $? -eq 0 ]; then \
    echo "$(echo `git status` | grep "nothing to commit" > /dev/null 2>&1; \
    if [ "$?" -eq "0" ]; then \
        echo "'$Green'"$(__git_ps1 "%s"); \
    else \
        echo "'$Red'"$(__git_ps1 "%s"); \
    fi) "; \
fi)'$Reset$PS1

# ALIASES
# remember aliases they can't use parameters, consider using functions instead
ll() {
    ls -la --color --human-readable --group-directories-first "${1:-.}" | more
}
lt() {
    # use fd to respect .gitignore
    # can be turned off with --no-ignore or -I (similar to fd)
    directory=""
    ignore="--ignore"
    while [[ $# -gt 0 ]]; do
      case $1 in
        -I|--no-ignore|--ignore)
          ignore="$1"
          shift
          ;;
        *)
          directory="$1"
          shift
          ;;
      esac
    done
    # If directory is empty or undefined, the whole ${directory:+"$directory"} thing
    # evaluates to the empty string, and since it's not double-quoted,
    # word splitting removes it entirely. On the other hand, if directory is nonblank,
    # it gets effectively replaced by "$directory".
    fd "$ignore" --type f --type l --hidden --exclude .git . ${directory:+"$directory"} | \
        tree --fromfile --dirsfirst -C -a | more
}
# look around in an unfamilar directory with combination of fd, fzf and tree
# respects .gitignore similar to fd
llf () {
    ignore=${1:---ignore}
    target=$( (echo '.'; fd "$ignore" --type d --hidden --exclude .git) | \
        fzf --preview "fd \"$ignore\" --type f --type l --hidden --exclude .git . {} | tree --fromfile --dirsfirst -C -a")
    if [ -n "$target" ]; then
        cd $target
    fi
}

alias grep="grep --color"
alias bat="bat -pp"

alias gs="git status --short"
alias gl="git log --oneline"
alias gd="git diff"
alias gb="git branch -v"
# master or main
alias gm='git switch $(git symbolic-ref refs/remotes/origin/HEAD | cut -d"/" -f4)'
alias gp="git pull"
alias gmgp="gm && gp"
# prune remote and local branches
gpr() {
    git fetch -p && \
    gone_branches=$(git for-each-ref --format '%(refname) %(upstream:track)' refs/heads | \
        awk '$2 == "[gone]" {sub("refs/heads/", "", $1); print $1}') && \
    git branch -v && \
    for branch in $gone_branches; do
        while true; do
            read -n 1 -p "Delete local branch \"$branch\"? " yn
            printf "\n"
            case $yn in
                [y]* ) git branch -D "$branch"; break;;
                [n]* ) break;;
                * ) printf "Please answer y or n.\n";;
            esac
        done
    done
}
gr() {
    git rebase -i HEAD~"${1:-2}"
}

alias dwn="cd $HOME/Downloads"
alias src="cd $HOME/Documents/sources"

alias tms="tmux_run start"
alias tme="tmux_run end"

# fuzzy find
eval "$(fzf --bash)"
export FZF_DEFAULT_COMMAND="fd --type f --type l --hidden --follow --exclude .git"
# fzf preview window vim-like scrolling
export FZF_DEFAULT_OPTS="--style full --layout reverse-list --bind ctrl-k:preview-up,\
ctrl-j:preview-down,\
ctrl-u:preview-half-page-up,\
ctrl-d:preview-half-page-down"
export FZF_CTRL_T_OPTS="
    --preview 'bat --style=numbers --color=always {}'"
export FZF_ALT_C_OPTS="
    --preview 'tree --dirsfirst -C {}'"
alias vi='vim -O `fzf --preview "bat --style=-numbers --color=always {}"`'
